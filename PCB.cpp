#include "pch.h"
#include "PCB.h"

/*时间片轮转调度是一种最古老，最简单，最公平且使用最广
的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允
许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分
配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。
调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。

进程进入等待队列的情况只有一种，就是执行态的进程由于某些原因被阻塞了，例如I/O请求，
从而进入对应的等待队列。而进程进入就绪队列的情况有两种，一是被阻塞的进程被唤醒，
从而离开相应的等待队列，并插入就绪队列；二是执行态的进程由于中断，或时间片用完，
再或者被抢占，而转入就绪态，并被插入就绪队列


模拟时间片轮转调度算法
操作时间代表该操作命令要执行多长时间（时间片个数）。这里假设I/O设备的数量没有限制，
I和O设备都只有一类。I，O，W三条指令实际上是不占有CPU的，
执行这三条指令就应该将进程放入对应的等待队列（输入等待队列，输出等待队列 ，其他等待队列）。

*/

/*
值传递（passl-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，
即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。
值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，
但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，
即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
*/


